PROJECT CONTEXT:
Create a mobile-first web application called "LotoMind AI" - an educational lottery analysis tool that uses Data Science and AI strategies to provide statistical insights. Target audience: 18+ lottery players interested in data-driven analysis. Tech stack: React, Tailwind CSS, Shadcn/UI, Lucide React (icons), Recharts, and Framer Motion. Supports real data import via .xlsx files and remote API fetching.

Core value proposition: Educational tool showing statistical analysis and patterns, NOT guaranteed predictions. Must emphasize responsible gaming and legal compliance throughout.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CRITICAL ADDITION: DATA SOURCES & IMPORT

Data Source Options:

1. Local File Import (.xlsx):
   - Add "Importar Resultados" button in Analytics screen header
   - Use SheetJS (xlsx) library to parse Excel files
   - Expected Excel structure:
     * Column A: Data do Sorteio (DD/MM/YYYY)
     * Column B: Concurso (number)
     * Columns C-H: NÃºmeros Sorteados (6 columns, numbers 01-60)
     * Column I: PrÃªmio (optional, currency format)
   - Validation: Check for 6 numbers per row, range 1-60, no duplicates
   - On success: Store in IndexedDB for persistence, show toast "X sorteios importados"
   - On error: Show detailed error message with row number

2. Remote Data Fetching:
   - Add "Atualizar da Internet" button (RefreshCw icon)
   - Fetch from mock API endpoint: https://api.loterias.exemplo.com.br/megasena/resultados
   - Expected JSON structure:
     ```json
     {
       "lottery": "mega-sena",
       "draws": [
         {
           "contest": 2650,
           "date": "2024-01-15",
           "numbers": [5, 12, 23, 34, 45, 58],
           "prize": 50000000
         }
       ]
     }
     ```
   - Loading state: "Buscando resultados atualizados..." with spinner
   - Cache strategy: Store last fetch timestamp, auto-refresh if > 7 days
   - Fallback: If fetch fails, use local data or bundled mock data

3. Data Management:
   - Use IndexedDB (via idb library) to store large datasets
   - Database structure:
     * Store: "draws" with index on date
     * Store: "metadata" for last update timestamp
   - Export feature: Allow user to download current data as .xlsx
   - Clear data: Button to reset and start fresh

Implementation Files:
- /src/lib/data-import/excelParser.ts (SheetJS integration)
- /src/lib/data-import/remoteFetcher.ts (API calls)
- /src/lib/data-import/indexedDBManager.ts (local storage)
- /src/lib/data-import/dataValidator.ts (validation logic)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CRITICAL ADDITION: FLEXIBLE BET GENERATION (6-20 NUMBERS)

User Configuration in AI Predictor Screen:

Add new section BEFORE Strategy Selector:

- "ConfiguraÃ§Ã£o do Jogo" Card (mb-6):
  
  * Number Selection Control:
    - Label: "Quantos nÃºmeros deseja gerar?" (text-sm font-semibold mb-2)
    - Shadcn Slider component:
      * min={6} max={20} step={1} defaultValue={6}
      * Visual display: Large number above slider showing current value (text-4xl font-mono)
      * Helper text below: "Gerando {value} nÃºmeros" (text-sm text-slate-400)
    - Info tooltip (HelpCircle icon):
      * "Mais nÃºmeros = maior cobertura, mas mais cartÃµes necessÃ¡rios"
      * Show cost calculation preview: "~{estimatedCards} cartÃµes Ã— R$ 5,00 = R$ {total}"
  
  * Game Quantity Selector:
    - Label: "Quantos jogos diferentes gerar?" (text-sm font-semibold mb-2)
    - Shadcn Select or Number Input:
      * Options: 1, 3, 5, 10, 20, 50 jogos
      * Helper text: "Cada jogo terÃ¡ {selectedNumbers} nÃºmeros otimizados"

Mathematical Explanation Card (collapsible):
- Title: "Como funciona a otimizaÃ§Ã£o?" (with ChevronDown icon)
- Content (when expanded):
  * "Ao selecionar mais de 6 nÃºmeros, o sistema gera a menor combinaÃ§Ã£o possÃ­vel de cartÃµes que cubram todos os nÃºmeros escolhidos."
  * Example visual:
    - Input: 10 nÃºmeros â†’ Output: 3-4 cartÃµes de 6 nÃºmeros
    - Show combinations tree diagram (optional)
  * "MÃ©todo: Cobertura por Sistemas Reduzidos (garantindo intersecÃ§Ãµes mÃ­nimas)"

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CRITICAL ADDITION: CARTESIAN OPTIMIZATION ALGORITHM

Card Optimization Logic:

When user selects N numbers (6-20) to generate, the system must:

1. Combinatorial Calculation:
   - Formula: C(n,6) = n! / (6! Ã— (n-6)!)
   - Examples:
     * 6 nÃºmeros â†’ 1 cartÃ£o (C(6,6) = 1)
     * 7 nÃºmeros â†’ 7 cartÃµes (C(7,6) = 7)
     * 8 nÃºmeros â†’ 28 cartÃµes (C(8,6) = 28)
     * 9 nÃºmeros â†’ 84 cartÃµes
     * 10 nÃºmeros â†’ 210 cartÃµes
   
2. Optimization Strategy (Sistema Reduzido):
   - Goal: Minimize number of cards while maximizing coverage
   - Use "Garantia MÃ­nima" approach:
     * Instead of all combinations, select strategic subsets
     * Ensure each number appears in multiple cards (redundancy)
     * Balance: Each card shares numbers with others to reduce cost
   
   - Optimization Levels (user selectable):
     a) "Completo" (Fechamento Total): All possible combinations
        - Pro: 100% coverage of all possibilities
        - Con: Expensive (many cards)
        - Use: When budget allows maximum coverage
     
     b) "Otimizado" (Sistema Reduzido - DEFAULT): Smart reduction
        - Pro: 60-80% coverage with 30-50% fewer cards
        - Con: Some combinations not covered
        - Algorithm: Greedy set cover approach
        - Use: Balanced cost/coverage
     
     c) "EconÃ´mico" (MÃ­nimo de CartÃµes): Minimal cards
        - Pro: Lowest cost
        - Con: ~40-50% coverage
        - Algorithm: Random sampling with constraint satisfaction
        - Use: Budget-constrained users

3. Implementation Algorithm (Optimized Strategy):
   
   ```typescript
   // /src/lib/optimization/cardOptimizer.ts
   
   interface OptimizationResult {
     cards: number[][]; // Array of 6-number arrays
     coverage: number; // Percentage (0-100)
     totalCost: number; // cards.length Ã— 5.00
     technique: string; // Name of optimization used
   }
   
   function optimizeCards(
     selectedNumbers: number[], // User's N numbers (6-20)
     strategy: 'complete' | 'optimized' | 'economical'
   ): OptimizationResult {
     
     if (selectedNumbers.length === 6) {
       return {
         cards: [selectedNumbers],
         coverage: 100,
         totalCost: 5.00,
         technique: "Jogo Simples"
       };
     }
     
     switch(strategy) {
       case 'complete':
         return generateAllCombinations(selectedNumbers);
       
       case 'optimized':
         return greedySetCover(selectedNumbers);
       
       case 'economical':
         return minimalCardSet(selectedNumbers);
     }
   }
   
   // Greedy Set Cover Algorithm
   function greedySetCover(numbers: number[]): OptimizationResult {
     const n = numbers.length;
     const targetCoverage = 0.7; // 70% coverage
     const maxCombinations = combinations(n, 6);
     const targetCards = Math.ceil(maxCombinations * targetCoverage);
     
     // Generate cards ensuring:
     // 1. Each number appears ~equally across cards
     // 2. Maximum overlap between cards (shared numbers)
     // 3. Diverse coverage (avoid repetitive patterns)
     
     // Implementation: Use balanced sampling with constraints
     // ... (detailed algorithm implementation)
   }

Visual Display in Results:

After "Run AI Simulation", show:

Summary Card (bg-blue-900/20 border-blue-500/50 p-4 rounded-lg mb-4):

Title: "OtimizaÃ§Ã£o Aplicada" (text-lg font-bold)
Metrics:"NÃºmeros Selecionados: {N}"
"CartÃµes Gerados: {X}"
"Cobertura: {Y}%" (with progress bar)
"Custo Total: R$ {X Ã— 5,00}"
"EstratÃ©gia: {strategy name}"


Info icon tooltip: Explanation of chosen optimization


Cards List (expandable accordion):

Each card shows 6 NumberBalls
Subtitle: "CartÃ£o {index} de {total}"
Highlight shared numbers between cards (different color/border)
Option to remove individual cards (recalculate cost)


Optimization Selector in UI:

Add after Number Selection Control:

Label: "NÃ­vel de OtimizaÃ§Ã£o" (text-sm font-semibold mb-2)
Radio Group (Shadcn RadioGroup):Option 1: "ğŸ’ Completo" Description: "Todas as combinaÃ§Ãµes possÃ­veis"
Cost preview: "{X} cartÃµes = R$ {cost}"


Option 2: "âš¡ Otimizado" (DEFAULT, with badge "Recomendado")Description: "Cobertura inteligente com menos cartÃµes"
Cost preview: "~{Y} cartÃµes = R$ {cost} (economia de {Z}%)"


Option 3: "ğŸ’° EconÃ´mico"Description: "MÃ­nimo de cartÃµes possÃ­vel"
Cost preview: "{W} cartÃµes = R$ {cost}"

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CRITICAL ADDITION: TRANSPARENT AI TECHNIQUES

AI Strategy Redesign (REPLACE previous section):

Each strategy must clearly explain its methodology and show transparency:

EstatÃ­stica ClÃ¡ssica (Classical Statistics):

Badge: "ğŸ“Š ESTATÃSTICA" (bg-blue-500/20 text-blue-400)


Description:

"AnÃ¡lise baseada em frequÃªncia, distribuiÃ§Ã£o e probabilidade"
"Usa apenas dados histÃ³ricos reais sem modelagem preditiva"


Techniques Used (show in expandable card):
a) FrequÃªncia de OcorrÃªncia:

Calculate: frequency_map = count(number) / total_draws
Weight: Hot numbers (top 20% frequency) get higher selection probability

b) AnÃ¡lise de Intervalo (Gap Analysis):

Calculate: draws_since_last_appearance for each number
Weight: Overdue numbers (gap > 2 standard deviations) included

c) DistribuiÃ§Ã£o Par/Ãmpar:

Historical ratio: even_avg / odd_avg
Constraint: Generated bet maintains Â±1 of historical ratio

d) DistribuiÃ§Ã£o Alta/Baixa:

Low (1-30) vs High (31-60) ratio from history
Constraint: Match historical distribution

e) Soma dos NÃºmeros:

Calculate: mean(sum(all_historical_draws))
Constraint: Generated bet sum within 1 std dev of mean


Output Display:

Show which rule influenced each number selection
Example: "NÃºmero 23: Alta frequÃªncia (89 vezes) + Intervalo normal (3 sorteios)"


RegressÃ£o Linear/LogÃ­stica (Regression Models):

Badge: "ğŸ“ˆ REGRESSÃƒO" (bg-purple-500/20 text-purple-400)


Description:

"Modelo estatÃ­stico que identifica tendÃªncias temporais"
"Analisa se nÃºmeros mostram padrÃµes crescentes/decrescentes ao longo do tempo"


Techniques Used:
a) RegressÃ£o Linear por NÃºmero:

For each number (1-60):X = draw_index (chronological order)
Y = binary (1 if number appeared, 0 if not)
Calculate: slope = Î”frequency / Î”time


Interpretation:Positive slope â†’ "NÃºmero em tendÃªncia de alta"
Negative slope â†’ "NÃºmero em tendÃªncia de baixa"
Near-zero slope â†’ "NÃºmero estÃ¡vel"

b) Logistic Regression (Probabilidade de OcorrÃªncia):

Features: [draws_since_last, total_frequency, position_in_range, even/odd]
Target: Will appear in next draw (binary: 0/1)
Train on 80% historical data, validate on 20%
Output: Probability score (0-1) for each number

c) Polynomial Regression (Ciclos):

Detect cyclical patterns: Numbers that appear in waves
Fit polynomial (degree 2-3) to frequency over time
Predict: Numbers at "peak" of their cycle


Output Display:

Show regression equation: "y = 0.023x + 0.15"
Chart: Line plot of predicted vs actual frequency
Confidence intervals: "NÃºmero 42: 78% de confianÃ§a (IC 95%: [0.65, 0.91])"


Machine Learning - Redes Neurais (Neural Networks):

Badge: "ğŸ§  DEEP LEARNING" (bg-green-500/20 text-green-400)


Description:

"Rede neural treinada em padrÃµes complexos e nÃ£o-lineares"
"Modelo experimental que aprende representaÃ§Ãµes latentes dos dados"


Architecture (show diagram):

Input Layer (60 neurons): One-hot encoding of last 5 draws (300 features)
Hidden Layer 1 (128 neurons): ReLU activation
Hidden Layer 2 (64 neurons): ReLU activation
Output Layer (60 neurons): Sigmoid activation (probability per number)


Techniques Used:
a) Sequence Learning (LSTM/GRU):

Input: Last N draws as sequence
Learn: Temporal dependencies between draws
Output: Probability distribution for next draw

b) Autoencoder (Pattern Recognition):

Train: Compress draw history to 10D latent space
Learn: Common patterns/clusters in historical data
Generate: Sample from latent space, decode to 6-number set

c) Ensemble Model:

Combine: 3 neural nets with different architectures
Voting: Numbers appearing in 2+ models get priority
Confidence: Agreement percentage across models


Training Details (show in modal):

Dataset: {total_draws} sorteios
Train/Test Split: 80/20
Epochs: 100 (with early stopping)
Loss Function: Binary Cross-Entropy
Optimizer: Adam (lr=0.001)
Validation Accuracy: XX% (realistic: ~15-20% for lottery)
Warning: "âš ï¸ Modelo experimental. Loteria Ã© aleatÃ³ria, IA nÃ£o garante resultados."


Output Display:

Show activation heatmap: Which neurons "fired" for selected numbers
Feature importance: Which input features influenced decision
Attention weights: Which past draws had most influence


Machine Learning - Clustering (Unsupervised Learning):

Badge: "ğŸ” CLUSTERING" (bg-yellow-500/20 text-yellow-400)


Description:

"Identifica grupos de nÃºmeros que aparecem juntos com frequÃªncia"
"AnÃ¡lise nÃ£o-supervisionada de padrÃµes de co-ocorrÃªncia"


Techniques Used:
a) K-Means Clustering:

Features: Co-occurrence matrix (60Ã—60) - how often pairs appear together
K: 6-8 clusters
Interpretation: Each cluster = "family" of related numbers
Selection: Pick 1-2 numbers from each cluster for diversity

b) DBSCAN (Density-Based):

Find: Dense regions in number space
Outliers: Numbers that rarely appear with others (avoid)
Core points: Frequently co-occurring numbers (prioritize)

c) Hierarchical Clustering:

Dendrogram: Visual tree of number relationships
Cut tree at optimal height to form groups
Generate: Pick numbers from different branches for coverage


Output Display:

Show cluster visualization: Scatter plot with colored groups
Cluster labels: "Cluster 1: NÃºmeros baixos frequentes" 
Justification: "2 nÃºmeros do Cluster A, 2 do Cluster B, 1 do C, 1 do D"


HÃ­brido Multi-TÃ©cnica (Ensemble Approach):

Badge: "âš¡ HÃBRIDO" (bg-gradient-to-r from-purple-500 to-green-500)


Description:

"Combina estatÃ­stica, regressÃ£o, ML e clustering em modelo Ãºnico"
"Sistema de votaÃ§Ã£o ponderado entre diferentes tÃ©cnicas"


Workflow:

Run all 4 techniques above in parallel
Each technique ranks all 60 numbers with score (0-1)
Weighted average: Statistics: 30%
Regression: 25%
Neural Network: 25%
Clustering: 20%


Select top N numbers based on combined score
Apply card optimization


Output Display:

Table showing each number's score per technique:NÂº  | Estat. | Regres. | Neural | Cluster | FINAL
----+--------+---------+--------+---------+-------
07  |  0.82  |  0.75   |  0.68  |  0.91   | 0.79 âœ“
23  |  0.76  |  0.83   |  0.72  |  0.65   | 0.74 âœ“
...


Highlight: Numbers selected, with their final score
Disagreement indicator: If techniques conflict, show warning icon

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

UI IMPLEMENTATION: TECHNIQUE TRANSPARENCY

Add "TransparÃªncia da IA" Section (after results are generated):

Collapsible Card: "ğŸ”¬ Como esses nÃºmeros foram escolhidos?"

Tab Navigation (Shadcn Tabs):

Tab 1: "Resumo Executivo"
Tab 2: "TÃ©cnicas Aplicadas"
Tab 3: "Dados Utilizados"
Tab 4: "LimitaÃ§Ãµes"


Tab 1 Content (Resumo):

List of techniques used with checkmarks
Key metrics: "ConfianÃ§a geral: 78%", "Sorteios analisados: 100"
Visual: Pie chart showing technique contribution weights


Tab 2 Content (TÃ©cnicas):

For each technique used:Name + Badge
Step-by-step explanation with icons
Mathematical formulas (in LaTeX-style display)
Example: "NÃºmero 23 foi selecionado porque: frequÃªncia (89Ã—) + tendÃªncia positiva (slope=+0.03) + cluster central"


Tab 3 Content (Dados):

Source: "Importado de arquivo Excel em {date}"
Total draws: {X}
Date range: "{first_date} atÃ© {last_date}"
Data quality: "âœ“ Sem inconsistÃªncias detectadas"
Button: "Ver dados brutos" (opens modal with data table)


Tab 4 Content (LimitaÃ§Ãµes):